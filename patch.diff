*** Begin Patch
*** Update File: AE PyDev.extension/lib/organized/MEPKit/tools/place_lighting_controls.py
@@
-        loops = boundary_loops(space) or []
-        processed_doors = set()
-
-        for loop in loops:
-            for seg in loop:
-                curve = segment_curve(seg)
-                wall = segment_host_wall(doc, seg)
-                if curve is None:
-                    continue
-                door_hits = door_points_on_wall(
-                    doc,
-                    wall,
-                    include_linked=True,
-                    link_tolerance_ft=max(near_door_ft + 2.0, 4.0),
-                    boundary_curve=curve,
-                )
-                for door, door_point in door_hits:
-                    door_key = _door_identifier(door, door_point)
-                    if door_key in processed_doors or door_key in global_processed_doors:
-                        continue
-
-                    wall_orientation = getattr(wall, "Orientation", None) if wall is not None else None
-                    wall_width = getattr(wall, "Width", None) if wall is not None else None
-                    meta_orient, meta_width = door_wall_meta(door)
-                    if wall_orientation is None and meta_orient is not None:
-                        wall_orientation = meta_orient
-                    if wall_width is None and meta_width is not None:
-                        wall_width = meta_width
-
-                    point = _switch_point_for_door(
-                        space,
-                        wall,
-                        door_point,
-                        near_door_ft,
-                        wall_orientation=wall_orientation,
-                        wall_width=wall_width,
-                        wall_curve=curve,
-                    )
-                    if not point:
-                        log.debug(u"[SKIP] No valid switch point near {} for space '{}'".format(
-                            _door_label(door, door_point), getattr(space, "Name", u"<unnamed>")))
-                        continue
-
-                    inst = _place_switch(doc, switch_symbol, wall, point,
-                                         mounting_height_ft=mounting_height_ft,
-                                         logger=log, level=level)
-                    if inst:
-                        processed_doors.add(door_key)
-                        global_processed_doors.add(door_key)
-                        switch_count += 1
-                    else:
-                        log.warning(u"[PLACE] Switch placement failed near {} in space '{}'".format(
-                            _door_label(door, door_point), getattr(space, "Name", u"<unnamed>")))
+        loops = boundary_loops(space) or []
+        processed_doors = set()
+        linked_wall_curves = []
+        space_switches = 0
+
+        for loop in loops:
+            for seg in loop:
+                curve = segment_curve(seg)
+                if curve is None:
+                    continue
+                wall = segment_host_wall(doc, seg)
+                if wall is None:
+                    length = _curve_length(curve)
+                    if length > 1e-3:
+                        linked_wall_curves.append((length, curve))
+                door_hits = door_points_on_wall(
+                    doc,
+                    wall,
+                    include_linked=True,
+                    link_tolerance_ft=max(near_door_ft + 2.0, 4.0),
+                    boundary_curve=curve,
+                )
+                for door, door_point in door_hits:
+                    door_key = _door_identifier(door, door_point)
+                    if door_key in processed_doors or door_key in global_processed_doors:
+                        continue
+
+                    wall_orientation = getattr(wall, "Orientation", None) if wall is not None else None
+                    wall_width = getattr(wall, "Width", None) if wall is not None else None
+                    meta_orient, meta_width = door_wall_meta(door)
+                    if wall_orientation is None and meta_orient is not None:
+                        wall_orientation = meta_orient
+                    if wall_width is None and meta_width is not None:
+                        wall_width = meta_width
+
+                    point = _switch_point_for_door(
+                        space,
+                        wall,
+                        door_point,
+                        near_door_ft,
+                        wall_orientation=wall_orientation,
+                        wall_width=wall_width,
+                        wall_curve=curve,
+                    )
+
+                    point_valid = point is not None
+                    if point_valid and space is not None:
+                        try:
+                            if not space.IsPointInSpace(point):
+                                point_valid = False
+                        except Exception:
+                            point_valid = True
+
+                    placement_wall = wall
+                    if not point_valid:
+                        point = _point_on_shortest_linked_wall(space, linked_wall_curves, min_inset_ft=2.0)
+                        placement_wall = wall if wall is not None else None
+
+                    if not point:
+                        log.debug(u"[SKIP] No valid switch point near {} for space '{}'".format(
+                            _door_label(door, door_point), getattr(space, "Name", u"<unnamed>")))
+                        continue
+
+                    inst = _place_switch(doc, switch_symbol, placement_wall, point,
+                                         mounting_height_ft=mounting_height_ft,
+                                         logger=log, level=level)
+                    if inst:
+                        processed_doors.add(door_key)
+                        global_processed_doors.add(door_key)
+                        space_switches += 1
+                        switch_count += 1
+                    else:
+                        log.warning(u"[PLACE] Switch placement failed near {} in space '{}'".format(
+                            _door_label(door, door_point), getattr(space, "Name", u"<unnamed>")))
+
+        if space_switches == 0 and linked_wall_curves:
+            fallback_point = _point_on_shortest_linked_wall(space, linked_wall_curves, min_inset_ft=2.0)
+            if fallback_point:
+                inst = _place_switch(doc, switch_symbol, None, fallback_point,
+                                     mounting_height_ft=mounting_height_ft,
+                                     logger=log, level=level)
+                if inst:
+                    switch_count += 1
*** End Patch
