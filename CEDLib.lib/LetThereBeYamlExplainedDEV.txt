Add YAML Profiles
Add YAML Profiles orchestrates the entire ingestion flow from user selection to serialized YAML. The
script starts in main() by calling _pick_profile_data_path, which checks the cached path stored by
the top-level Select YAML pushbutton. Once the file is known, _load_profile_store loads it into
memory and main() prompts the user to select one or more Revit elements. For each element,
_build_type_entry executes: it inspects the FamilySymbol or GroupType, determines whether the entry
is a model group or family instance, samples Location.Point (or the midpoint of Location.Curve), and
pushes those feet-based values through _feet_to_inches so offsets are stored as inches. The helper
also calls _collect_params, which iterates Parameters and matches names against an alias table (dev-
Group ID, CKT_Rating_CED, CKT_Panel_CEDT, etc.). The resulting dictionary becomes the
linked_element_definition static parameter block.
The next step is _collect_hosted_tags. It calls Element.GetDependentElements(None), filters for
IndependentTag instances, and for each tag records the tag type family, symbol name, category, and
the XYZ delta between tag.TagHeadPosition and the host element point. Those values are converted to
inches and appended to the instance_config.tags list so the placement engine can recreate annotation
families later. Finally, ensure_equipment_definition guarantees the CAD profile exists, get_type_set
fetches the linked_set, next_led_id assigns an ID, and the assembled dictionary
(offsets/parameters/tags) is appended to linked_element_definitions. save_profile_data writes the
updated dataset back to disk and _log_entry writes a JSON row to profileData.log containing
timestamp, action="add", cad_name, labels, and user.

Delete YAML Profiles
Delete YAML Profiles manipulates profileData.yaml entirely in memory. After resolving the path and
loading it through _load_profile_store, the script enumerates CAD names and their labels, then uses
SelectFromList with multiselect so the operator can choose multiple labels to remove. For each
label, linked_element_definitions is rebuilt without entries whose label string matches the
selection; all other metadata (linked set IDs, names, parent filters) stay intact. _file_hash runs
before and after save_profile_data so profileData.log can record a before/after hash,
action="delete", definition name, labels removed, and the operator name. Because this tool depends
on unique label strings, duplicates could remove unexpected entries, so the catalog author must
ensure each label within a CAD profile is unique.

Edit YAML Profiles
Edit YAML Profiles uses a shim layer so the legacy Element Linker UI can edit YAML-driven data.
profile_schema.equipment_defs_to_legacy converts the YAML into shim objects (ProfileShim,
TypeConfigShim, InstanceConfigShim) that expose the properties expected by ProfileEditorWindow.xaml.
The WPF window populates ProfileCombo with CAD names and TypeCombo with labels discovered by
_discover_type_configs, which scans profile.__dict__ attributes for TypeConfig lists. When the
operator selects a label, TypeCombo_SelectionChanged loads the first OffsetShim, builds parameter
rows by pairing TextBlocks and TextBoxes, and builds tag rows with editable fields. After the user
clicks OK, OkButton_Click gathers the edited offsets/parameters/tags, the script converts the shims
back via legacy_to_equipment_defs, hashes the original file, writes the new YAML through
save_profile_data, hashes again, and logs action="edit" with the CAD names touched plus the
before/after hashes.

Load Equipment Definition
Load Equipment Definition sanitizes the YAML structures and feeds them directly to
PlaceElementsEngine. _load_profile_store loads the YAML and _sanitize_equipment_definitions ensures
every linked element has offset, parameter, and tag lists (defaulting to [{}], {}, and []).
ProfileRepository._parse_profiles then builds EquipmentDefinition objects keyed by CAD name so
lookups are constant time. The operator picks a CAD profile and, optionally, a tagging view via
ViewChoice; thereafter the script asks for a base point. The placement step is delegated to
PlaceElementsEngine, which activates missing FamilySymbols, drops model groups or families at the
placement point, copies static parameters, and calls _place_tags for each tag dictionary.
IndependentTag.Create is invoked with has_leader=True so all tags share the same leader style.
Failures raise forms.alert messages listing the CAD name and label so troubleshooting is
straightforward.

PlaceElements
PlaceElements is the batch runner that mirrors the legacy CSV workflow but uses YAML definitions.
After resolving the cached file it loads profileData via ProfileRepository, optionally reads
coordinate CSVs through read_xyz_csv, and opens PlaceElementsWindow. That WPF dialog allows the user
to select one or more CAD profiles, map CSV columns to X/Y/Z coordinates, choose repetition counts,
and define target views for tagging. When the dialog returns, the script builds a queue of
placements (each containing CAD name, label, XYZ, rotation, view, and repetition count) and enters a
single Revit Transaction. PlaceElementsEngine iterates this queue, activates symbols, places
hosts/groups, runs _apply_parameters to copy static metadata, and calls _place_tags when tag
dictionaries exist. All placements occur inside one transaction, so a failure anywhere triggers a
rollback; accordingly the script validates that all CAD names exist and all requested views are
available before invoking the engine. Summary counts are printed to the Revit output panel once the
transaction succeeds.

Set New XYZ Offset
Set New XYZ Offset recalibrates location metadata for a single linked element definition. The script
prompts the user to select an instance, extracts its label (e.g., “EF-U_Receptacle_CED : Duplex
Wall”) and CAD name, and resolves that entry inside the YAML dictionary. The operator then clicks a
new preview point; the script subtracts the element’s current Location from the preview to get a
delta vector, converts it to inches, and writes those numbers into led_entry['offsets'][0].
save_profile_data writes the update and _log_entry appends action="set_xyz_offset" plus the LED id
and values to profileData.log. Finally, ElementTransformUtils.MoveElement attempts to translate the
live element by the same delta so the preview matches the stored calibration. If the move fails (for
pinned or constrained elements) a warning is displayed but the YAML change remains.

Set New Rotation Offset
The rotation helper follows the same pattern but manipulates the stored angle. After the user picks
an element and defines a preview rotation, the script samples the current orientation (via
Location.Rotation or FacingOrientation), computes an angular delta in degrees, and writes that value
into the first offset entry. save_profile_data persists the change, profileData.log records
action="set_rotation_offset", and ElementTransformUtils.RotateElement attempts to rotate the live
instance around its insertion point. Exceptions for non-rotatable elements are caught and reported
while the YAML still reflects the new rotation, ensuring catalog data matches the operator’s intent.

Tag Equipment
Tag Equipment bridges the catalog’s tag definitions with the current Revit view. The script loads
profileData via ProfileRepository, flattens every tag dictionary, and groups them by
family/type/category using LogicClasses.tag_utils.tag_key_from_dict so duplicate entries are merged.
SelectFromList displays the deduplicated list but each entry retains all of its “contexts” (CAD
name, label, dev-Group ID, and tag offsets). After the user selects one or more entries,
_collect_instance_lookup gathers FamilyInstances in the active view and creates multiple key
variants (exact label, base label without “#n”, canonical family:type combination). For each
context, the script filters hosts by the stored dev-Group ID, uses placed_tag_pairs (host id plus
tag key) to avoid duplicates, and calls PlaceElementsEngine._place_tags. That helper computes final
tag locations, calls IndependentTag.Create with leaders enabled, rotates the tag head if needed, and
applies any parameter overrides stored in the YAML. A summary alert reports how many hosts were
tagged and which labels had no matches so the user can adjust dev-Group IDs or visibility filters
accordingly.