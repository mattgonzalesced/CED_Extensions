Place Linked Elements – Code Explained
=====================================

Objective
---------
Automate the placement of every equipment definition stored in Extensible
Storage by matching host elements (or linked instances) to the CAD names recorded
in the YAML. Each placement replay the captured offsets, rotations, tags, and
parameters exactly as Select Parent Element or Update Vector saved them.

Execution Pipeline
------------------
1. **Repository Build** – `load_active_yaml_data` feeds `equipment_defs_to_legacy`
   and `ProfileRepository._parse_profiles`, producing an object model where each
   CAD name exposes its linked element definitions (LEDs).
2. **Host Discovery** – `_collect_placeholders` walks FamilyInstances/Groups and
   RevitLinkInstances, normalizes their names (`_name_variants`), transforms
   linked coordinates into the host document, and stores base points + rotations
   for every name that matches a CAD definition.
3. **Row Construction** – For every match we build a “CSV row” describing
   placement coordinates (in inches) and rotation. `selection_map` ties each CAD
   name to the list of LED labels that should be instantiated.
4. **Placement Engine** – `PlaceElementsEngine.place_from_csv` does the heavy
   lifting: activating symbols, placing families or groups, applying the offset
   tuples from the YAML, stamping the Element_Linker payload (with parent
   rotation), and creating hosted tags when the definition supplies them.
5. **Reporting** – After the run we summarize processed hosts, actual placements,
   and any definitions that still lack matching hosts or linked types. This ties
   directly into QA/QC so designers know which names still need aliasing.

Important Behaviors
-------------------
* The engine writes Element_Linker data to every instance so Update Vector, Tag
  Equipment, and QA/QC can find them immediately.
* Linked models are fully supported because points/rotations are transformed into
  project coordinates before placement.
* The command is undoable; each placement batch executes inside a single Revit
  transaction for consistency.

If no matches or rows are produced, the script raises an alert instead of running
the engine, preventing partially configured data from creating stray elements.
