# -*- coding: utf-8 -*-
# Color Circuits by Panel  |  Revit Python 2.7 – pyRevit / Revit API
# - Creates/updates: per-panel multi-category OR filters (per your screenshot)
# - Colors current (or new) plan/RCP/3D view using overrides (unique for included, grey+halftone for others)
# - Creates/updates legend drafting view with swatches + labels (swatches keyed via Comments)
# - DOES NOT modify or create any View Templates
# - MODIFIED: Generates maximally contrasting colors based on number of selected panels

from System.Collections.Generic import List
from pyrevit import revit, DB, forms, script
import math

logger = script.get_logger()
output = script.get_output()
doc = revit.doc

# -----------------------------------------------------------------------------
# 0) Constants
# -----------------------------------------------------------------------------
FILTER_PREFIX = "PanelChecker - {0} - {1}"      # part_type, panel_name
LEGEND_VIEW_NAME = "PanelChecker Legend"
FILLED_REGION_TYPE_NAME = "PanelChecker - Solid Fill"
VIEW_TEMPLATE_NAME = "E_PanelChecker View"

BIP_PANEL_ON_DEVICES = DB.BuiltInParameter.RBS_ELEC_CIRCUIT_PANEL_PARAM
BIP_COMMENTS = DB.BuiltInParameter.ALL_MODEL_INSTANCE_COMMENTS

DEVICE_FIXTURE_OR_CATS = [
    DB.BuiltInCategory.OST_DetailComponents,
    DB.BuiltInCategory.OST_ElectricalEquipment,
    DB.BuiltInCategory.OST_ElectricalFixtures,
    DB.BuiltInCategory.OST_DataDevices,
    DB.BuiltInCategory.OST_FireAlarmDevices,
    DB.BuiltInCategory.OST_LightingDevices,
    DB.BuiltInCategory.OST_LightingFixtures,
    DB.BuiltInCategory.OST_MechanicalControlDevices,
    DB.BuiltInCategory.OST_SecurityDevices,
]

# Fallback palette for when dynamic generation fails
COLOR_PALETTE = [
    (60, 180, 75), (255, 225, 25), (67, 99, 216),
    (245, 130, 48), (145, 30, 180), (70, 240, 240), (240, 50, 230),
    (210, 245, 60), (250, 190, 190), (0, 128, 128), (230, 190, 255),
    (170, 110, 40), (255, 250, 200), (170, 255, 195),
    (128, 128, 0), (255, 215, 180), (0, 0, 128),
]
GREY = (160, 160, 160)

# -----------------------------------------------------------------------------
# 1) Small helpers
# -----------------------------------------------------------------------------
def _rgb(r, g, b):
    return DB.Color(bytearray([r])[0], bytearray([g])[0], bytearray([b])[0])

def _as_sorted_unique(items):
    seen = set()
    out = []
    for s in items:
        if s and s not in seen:
            seen.add(s)
            out.append(s)
    out.sort()
    return out

# -----------------------------------------------------------------------------
# 1.5) Color generation functions for maximum contrast
# -----------------------------------------------------------------------------
def generate_max_contrast_colors(num_colors):
    """
    Generate maximally contrasting colors using HSL color space.
    Distributes hues evenly, varies saturation and lightness for better contrast.
    Excludes red hues (0-30 degrees and 330-360 degrees in hue circle).
    """
    if num_colors <= 0:
        return []

    colors = []

    # For very small numbers, use hand-picked high contrast colors
    if num_colors == 1:
        return [(255, 0, 0)]  # Red
    elif num_colors == 2:
        return [(255, 0, 0), (0, 255, 255)]  # Red and Cyan
    elif num_colors == 3:
        return [(255, 0, 0), (0, 255, 0), (0, 0, 255)]  # Red, Green, Blue
    elif num_colors == 4:
        return [(255, 0, 0), (0, 255, 0), (0, 0, 255), (255, 255, 0)]  # Red, Green, Blue, Yellow

    # For larger numbers, use algorithmic generation
    # Use CIELAB color space for perceptually uniform spacing
    # Generate colors in a circle around the a*b* plane avoiding red region

    for i in range(num_colors):
        # Generate angle avoiding red spectrum (330° to 30° in hue space)
        # Map to a*b* plane angle, avoiding red region
        angle_range = 300.0  # degrees available (avoiding 60° red zone)
        start_angle = 30.0   # start at 30° to avoid red

        angle_deg = start_angle + (i / float(num_colors)) * angle_range
        angle_rad = math.radians(angle_deg)

        # Adjust L* slightly to counteract Bezold-Brücke shift
        L = 60.0 + 5.0 * math.sin(2 * angle_rad)  # Varies L* by ±5 based on hue

        # Generate a* and b* values on a circle (for vivid colors)
        chroma = 60.0  # High chroma for vivid colors
        a = chroma * math.cos(angle_rad)
        b = chroma * math.sin(angle_rad)

        # Convert CIELAB to RGB
        rgb = lab_to_rgb(L, a, b)
        colors.append(rgb)

    return colors

def lab_to_rgb(l, a, b):
    """Convert CIELAB color to RGB. L in [0, 100], a,b in [-128, 127], returns (r, g, b) in [0, 255]"""
    # Convert LAB to XYZ
    fy = (l + 16.0) / 116.0
    fx = a / 500.0 + fy
    fz = fy - b / 200.0

    # Convert to XYZ
    def f_inv(t):
        if t > 6.0/29.0:
            return t ** 3
        else:
            return 3.0 * (6.0/29.0) ** 2 * (t - 4.0/29.0)

    # D65 white point
    xn, yn, zn = 95.047, 100.0, 108.883

    x = xn * f_inv(fx)
    y = yn * f_inv(fy)
    z = zn * f_inv(fz)

    # Convert XYZ to RGB (sRGB matrix)
    r =  3.2406 * x - 1.5372 * y - 0.4986 * z
    g = -0.9689 * x + 1.8758 * y + 0.0415 * z
    b =  0.0557 * x - 0.2040 * y + 1.0570 * z

    # Gamma correction
    def gamma_correct(c):
        if c <= 0.0031308:
            return 12.92 * c
        else:
            return 1.055 * (c ** (1.0/2.4)) - 0.055

    r = gamma_correct(r / 100.0)
    g = gamma_correct(g / 100.0)
    b = gamma_correct(b / 100.0)

    # Clamp to [0, 1] and convert to [0, 255]
    r = max(0, min(1, r))
    g = max(0, min(1, g))
    b = max(0, min(1, b))

    return (int(r * 255), int(g * 255), int(b * 255))


def optimize_color_distances(colors, num_colors):
    """
    Optimize color selection for maximum perceptual distance.
    Uses a simplified LAB color distance approximation.
    Avoids red hues (0-60° and 300-360°).
    """
    if num_colors <= 8:
        return colors

    # Start with evenly distributed colors in HSV space
    optimized = []

    # Define primary anchors for better distribution (no red colors)
    anchors = [
        (0, 255, 0),      # Green
        (0, 0, 255),      # Blue
        (255, 255, 0),    # Yellow
        (255, 0, 255),    # Magenta
        (0, 255, 255),    # Cyan
        (255, 128, 0),    # Orange
        (128, 0, 255),    # Purple
        (0, 128, 0),      # Dark Green
        (0, 0, 128),      # Navy
        (255, 192, 203),  # Pink
        (165, 42, 42),    # Brown
        (255, 215, 0),    # Gold
        (75, 0, 130),     # Indigo
    ]

    # Use anchors first if we need them
    if num_colors <= len(anchors):
        # Pick the most distinct anchors
        step = len(anchors) / float(num_colors)
        for i in range(num_colors):
            idx = int(i * step)
            optimized.append(anchors[idx])
    else:
        # Use all anchors and generate more
        optimized = list(anchors)

        # Generate additional colors
        while len(optimized) < num_colors:
            best_color = None
            best_min_dist = 0

            # Try several random colors and pick the one with max min distance
            for _ in range(20):
                # Generate a random color with good saturation, avoiding red hues
                import random
                # Generate hue in allowed range (60° to 300°)
                allowed_hue_range = 240.0 / 360.0  # 0.667
                start_hue = 60.0 / 360.0  # 0.167
                h = start_hue + random.random() * allowed_hue_range

                s = 0.6 + random.random() * 0.4
                l = 0.3 + random.random() * 0.4
                # Convert hue to CIELAB a*b* coordinates
                angle_rad = math.radians(h * 360.0)
                chroma = 60.0
                a = chroma * math.cos(angle_rad)
                b = chroma * math.sin(angle_rad)
                candidate = lab_to_rgb(60.0, a, b)

                # Calculate minimum distance to existing colors
                min_dist = float('inf')
                for existing in optimized:
                    dist = color_distance(candidate, existing)
                    if dist < min_dist:
                        min_dist = dist

                if min_dist > best_min_dist:
                    best_min_dist = min_dist
                    best_color = candidate

            if best_color:
                optimized.append(best_color)

    return optimized[:num_colors]

def color_distance(c1, c2):
    """
    Calculate perceptual color distance using weighted Euclidean distance.
    This is a simplified approximation of LAB color distance.
    """
    r1, g1, b1 = c1
    r2, g2, b2 = c2

    # Weight factors for perceptual difference
    # Human eye is more sensitive to green, less to blue
    dr = (r1 - r2) * 0.30
    dg = (g1 - g2) * 0.59
    db = (b1 - b2) * 0.11

    return math.sqrt(dr*dr + dg*dg + db*db)

# -----------------------------------------------------------------------------
# 2) Panel discovery
# -----------------------------------------------------------------------------
def get_electrical_equipment(doc):
    return list(DB.FilteredElementCollector(doc)
                .OfCategory(DB.BuiltInCategory.OST_ElectricalEquipment)
                .WhereElementIsNotElementType())

def get_all_panel_names(doc):
    names = []
    for eq in get_electrical_equipment(doc):
        ok = True
        try:
            ds = eq.LookupParameter("Distribution System")
            if ds is None or not ds.HasValue or not ds.AsElementId() \
               or ds.AsElementId() == DB.ElementId.InvalidElementId:
                ok = False
        except Exception:
            ok = False
        if not ok:
            continue
        pn = None
        try:
            p = eq.LookupParameter("Panel Name")
            if p and p.HasValue:
                pn = p.AsString()
        except Exception as ex:
            logger.debug("Could not read Panel Name on equipment id {0}: {1}"
                         .format(eq.Id.IntegerValue, ex))
        if pn:
            names.append(pn.strip())
    return _as_sorted_unique(names)

# -----------------------------------------------------------------------------
# 3) Filter creation (ONE filter per panel, OR across category-scoped rules)
# -----------------------------------------------------------------------------
def rect_curveloops(x, y, w, h):
    p0 = DB.XYZ(x,     y,     0.0)
    p1 = DB.XYZ(x + w, y,     0.0)
    p2 = DB.XYZ(x + w, y + h, 0.0)
    p3 = DB.XYZ(x,     y + h, 0.0)
    loop = DB.CurveLoop()
    loop.Append(DB.Line.CreateBound(p0, p1))
    loop.Append(DB.Line.CreateBound(p1, p2))
    loop.Append(DB.Line.CreateBound(p2, p3))
    loop.Append(DB.Line.CreateBound(p3, p0))
    outer = List[DB.CurveLoop]()
    outer.Add(loop)
    return outer

def get_or_create_filled_region_type(doc, type_name):
    for frt in DB.FilteredElementCollector(doc).OfClass(DB.FilledRegionType):
        if DB.Element.Name.__get__(frt) == type_name:
            return frt
    base = DB.FilteredElementCollector(doc).OfClass(DB.FilledRegionType).FirstElement()
    if base is None:
        logger.debug("No base FilledRegionType available to duplicate.")
        return None
    try:
        new_frt = base.Duplicate(type_name)  # returns FilledRegionType, NOT ElementId
        return new_frt
    except Exception as ex:
        logger.debug("Failed to duplicate FilledRegionType: {}".format(ex))
        return None


def pick_text_type():
    types = list(DB.FilteredElementCollector(doc).OfClass(DB.TextNoteType))
    preferred = None
    fallback = types[0] if types else None
    for t in types:
        try:
            name = t.get_Parameter(DB.BuiltInParameter.SYMBOL_NAME_PARAM).AsString() or ""
            font = t.get_Parameter(DB.BuiltInParameter.TEXT_FONT).AsString() or ""
            if ("3/32" in name) and ("Arial" in font):
                return t
        except Exception:
            continue
    return preferred or fallback

# -----------------------------------------------------------------------------
# 4) Overrides + apply to a single view (no templates touched)
# -----------------------------------------------------------------------------
def get_or_create_view_template(template_name):
    active_view = revit.active_view
    if not isinstance(active_view, DB.ViewPlan) or active_view.ViewType != DB.ViewType.FloorPlan:
        forms.alert("Active view must be a floor plan to create a view template.",script)
        return None

    # Check for existing template
    for v in DB.FilteredElementCollector(doc).OfClass(DB.View).WhereElementIsNotElementType():
        if v.IsTemplate and v.Name == template_name:
            return v

    try:
        template = active_view.CreateViewTemplate()
        template.Name = template_name
        logger.debug("Created new view template from active view: {}".format(active_view.Name))
        return template
    except Exception as ex:
        logger.debug("Failed to create template from active view: {}".format(ex))
        return None

def enforce_template_controls_only_filters(template_view):
    try:
        filters_param_id = None
        param_ids_to_exclude = List[DB.ElementId]()

        for param in template_view.Parameters:
            try:
                defn = param.Definition
                if defn is None:
                    continue

                bip = getattr(defn, "BuiltInParameter", None)
                if bip == DB.BuiltInParameter.VIS_GRAPHICS_FILTERS:
                    filters_param_id = param.Id
                    logger.debug("Identified 'V/G Overrides Filters' correctly.")
                else:
                    param_ids_to_exclude.Add(param.Id)
                    logger.debug("Excluding from control: '{}' (BuiltIn: {})"
                                 .format(defn.Name, bip))

            except Exception as inner_ex:
                logger.debug("Error evaluating parameter: {}".format(inner_ex))

        if filters_param_id is None:
            logger.debug("Failed to find 'V/G Overrides Filters' built-in parameter.")
            return

        template_view.SetNonControlledTemplateParameterIds(param_ids_to_exclude)
        logger.debug("Successfully restricted view template to only control V/G Filters")

    except Exception as ex:
        logger.debug("Failed to restrict template controls: {}".format(ex))


def apply_filters_to_template(view_template, filter_override_data):
    try:
        current_filters = list(view_template.GetFilters())
        for f_id in current_filters:
            filt = doc.GetElement(f_id)
            if not filt or not filt.Name.startswith("PanelChecker -"):
                view_template.RemoveFilter(f_id)
    except Exception as ex:
        logger.debug("Failed to clear old filters: {0}".format(ex))

    for pfe, ogs in filter_override_data:
        try:
            if not view_template.IsFilterApplied(pfe.Id):
                view_template.AddFilter(pfe.Id)
            view_template.SetFilterOverrides(pfe.Id, ogs)
            view_template.SetFilterVisibility(pfe.Id, True)
        except Exception as ex:
            logger.debug("Failed to apply filter '{0}' to template: {1}".format(pfe.Name, ex))

def activate_temp_view_mode(view, template):
    try:
        if view.IsTemporaryViewPropertiesModeEnabled():
            view.DisableTemporaryViewMode(DB.TemporaryViewMode.TemporaryViewProperties)
        view.EnableTemporaryViewPropertiesMode(template.Id)
        logger.debug("Activated temporary view mode with template: {}".format(template.Name))
    except Exception as ex:
        logger.debug("Failed to activate temporary view mode: {}".format(ex))


def build_overrides(color_tuple, use_halftone, solid_fill_pattern_id):
    r, g, b = color_tuple
    col = _rgb(r, g, b)
    ogs = DB.OverrideGraphicSettings()
    try:
        ogs.SetProjectionLineColor(col)
    except Exception:
        pass
    try:
        # if these APIs exist in your version, great; otherwise color still comes via lines
        ogs.SetSurfaceForegroundPatternId(solid_fill_pattern_id)
        ogs.SetSurfaceForegroundPatternColor(col)
    except Exception:
        pass
    try:
        ogs.SetHalftone(bool(use_halftone))
    except Exception:
        pass
    return ogs


# -----------------------------------------------------------------------------
# 5) Legend view + filled regions (swatches)
# -----------------------------------------------------------------------------

def get_solid_fill_pattern_id(doc):
    for fpe in DB.FilteredElementCollector(doc).OfClass(DB.FillPatternElement):
        try:
            fp = fpe.GetFillPattern()
            if fp.Target == DB.FillPatternTarget.Drafting and fp.IsSolidFill:
                return fpe.Id
        except Exception:
            pass
    raise Exception("No Solid Fill pattern found in document.")


def get_filled_region_type(name):
    # Just return the first one available, regardless of name
    fr_type = DB.FilteredElementCollector(doc).OfClass(DB.FilledRegionType).FirstElement()
    if not fr_type:
        logger.debug("No FilledRegionType available in document.")
        return None
    return fr_type

def get_filled_region_type_thisisbroken(name):
    for frt in DB.FilteredElementCollector(doc).OfClass(DB.FilledRegionType):
        if DB.Element.Name.__get__(frt) == name:
            logger.debug("get filled region type - first return")
            return frt

    base = DB.FilteredElementCollector(doc).OfClass(DB.FilledRegionType).FirstElement()
    if not base:
        logger.debug("No base FilledRegionType available to duplicate.")
        return None

    new_type = None
    new_type_id = base.Duplicate(name)
    new_ref = DB.Reference(new_type_id)
    new_type = doc.GetElement(new_ref)

    # Must be done *inside* transaction
    new_type.ForegroundPatternId = base.ForegroundPatternId
    new_type.ForegroundPatternColor = base.ForegroundPatternColor
    new_type.BackgroundPatternId = base.BackgroundPatternId
    new_type.BackgroundPatternColor = base.BackgroundPatternColor
    logger.debug("get filled region type - first return")
    return new_type



def get_or_create_drafting_view(view_name, scale_int, template):
    legend_view = next((v for v in DB.FilteredElementCollector(doc).OfClass(DB.ViewDrafting)
                        if v.Name == view_name), None)
    if legend_view:
        logger.debug("legend exists already!")
        return legend_view

    vft = next((x for x in DB.FilteredElementCollector(doc).OfClass(DB.ViewFamilyType)
                if x.ViewFamily == DB.ViewFamily.Drafting), None)
    if not vft:
        logger.debug("No Drafting ViewFamilyType found.")
        return None

    legend_view = DB.ViewDrafting.Create(doc, vft.Id)
    legend_view.Name = LEGEND_VIEW_NAME
    legend_view.Scale = 48
    legend_view.ViewTemplateId = template.Id
    logger.debug("I CREATED A NEW DRAFTING VIEW!")
    return legend_view

def create_or_update_legend_drafting_view(legend_view, color_map, template, fr_type):

    if not legend_view:
        logger.debug("Legend view creation failed.")
        return

    # Set name, scale, and view template
    try:
        legend_view.Name = LEGEND_VIEW_NAME
        legend_view.Scale = 48
        if template:
            legend_view.ViewTemplateId = template.Id
    except Exception as ex:
        logger.debug("Failed to set legend view props: {}".format(ex))

    if not fr_type:
        logger.debug("No filled region type found.")
        return

    ttype = pick_text_type()
    if not ttype:
        logger.debug("No valid TextNoteType found.")
        return

    view_items = DB.FilteredElementCollector(doc, legend_view.Id)
    deletable_items = [el for el in view_items
                       if isinstance(el,DB.FilledRegion) or isinstance(el,DB.TextNote)]
    for el in deletable_items:
        try:
            doc.Delete(el.Id)
        except Exception as ex:
            logger.debug("Failed to delete element {}: {}".format(el.Id, ex))


    width, height, spacing, text_dx = 1.0, 0.5, 1.0, 1.0

    for idx, (panel_name, rgb) in enumerate(color_map):
        x, y = 0.0, idx * spacing
        loops = rect_curveloops(x, y, width, height)

        try:
            filled = DB.FilledRegion.Create(doc, fr_type.Id, legend_view.Id, loops)
            comment_param = filled.LookupParameter("Comments")
            if comment_param:
                comment_param.Set(panel_name)
        except Exception as ex:
            logger.debug("Failed to create filled region for {}: {}".format(panel_name, ex))

        try:
            pt = DB.XYZ(x + width + text_dx, y + height * 0.5, 0.0)
            opts = DB.TextNoteOptions()
            opts.TypeId = ttype.Id
            opts.VerticalAlignment = DB.VerticalTextAlignment.Middle
            DB.TextNote.Create(doc, legend_view.Id, pt, panel_name, opts)
        except Exception as ex:
            logger.debug("Failed to create text note for {}: {}".format(panel_name, ex))




def create_or_update_panel_filter_logical_or(panel_name):
    """Creates or updates a ParameterFilterElement with a Logical OR of per-category ElementParameterFilters."""
    logger.debug("Building filter: Panel Checker - {0}".format(panel_name))
    filter_name = "Panel Checker - {0}".format(panel_name)

    # Categories and their corresponding parameter BIP for string match
    category_param_map = {
        DB.BuiltInCategory.OST_DetailComponents: DB.BuiltInParameter.ALL_MODEL_INSTANCE_COMMENTS,
        DB.BuiltInCategory.OST_ElectricalEquipment: DB.BuiltInParameter.RBS_ELEC_PANEL_NAME,
        DB.BuiltInCategory.OST_ElectricalFixtures: DB.BuiltInParameter.RBS_ELEC_CIRCUIT_PANEL_PARAM,
        DB.BuiltInCategory.OST_DataDevices: DB.BuiltInParameter.RBS_ELEC_CIRCUIT_PANEL_PARAM,
        DB.BuiltInCategory.OST_FireAlarmDevices: DB.BuiltInParameter.RBS_ELEC_CIRCUIT_PANEL_PARAM,
        DB.BuiltInCategory.OST_LightingDevices: DB.BuiltInParameter.RBS_ELEC_CIRCUIT_PANEL_PARAM,
        DB.BuiltInCategory.OST_LightingFixtures: DB.BuiltInParameter.RBS_ELEC_CIRCUIT_PANEL_PARAM,
        DB.BuiltInCategory.OST_MechanicalControlDevices: DB.BuiltInParameter.RBS_ELEC_CIRCUIT_PANEL_PARAM,
        DB.BuiltInCategory.OST_SecurityDevices: DB.BuiltInParameter.RBS_ELEC_CIRCUIT_PANEL_PARAM,
    }

    # Collect valid filters
    or_filters = []
    cat_ids = []

    for bic, bip in category_param_map.items():
        try:
            cat = doc.Settings.Categories.get_Item(bic)
            cat_id = cat.Id
            cat_ids.append(cat_id)

            # Build FilterCategoryRule with correct collection
            cat_rule = DB.FilterCategoryRule(List[DB.ElementId]([cat_id]))
            val_rule = DB.FilterStringRule(
                DB.ParameterValueProvider(DB.ElementId(bip)),
                DB.FilterStringEquals(),
                panel_name,
            )
            filter_rules = List[DB.FilterRule]([cat_rule, val_rule])
            epf = DB.ElementParameterFilter(filter_rules)

            or_filters.append(epf)
            logger.debug("Added rule for category: {0}".format(bic.ToString()))
        except Exception as ex:
            logger.debug("Failed to build rule for category {0}: {1}".format(bic.ToString(), ex))

    if not or_filters:
        logger.debug("No valid filters for panel '{0}'".format(panel_name))
        return None

    try:
        final_filter = DB.LogicalOrFilter(List[DB.ElementFilter](or_filters))
    except Exception as ex:
        logger.debug("Failed to create LogicalOrFilter for panel '{0}': {1}".format(panel_name, ex))
        return None

    # Look for existing ParameterFilterElement
    existing = None
    for pfe in DB.FilteredElementCollector(doc).OfClass(DB.ParameterFilterElement):
        if pfe.Name == filter_name:
            existing = pfe
            break

    try:
        if existing:
            existing.SetCategories(List[DB.ElementId](cat_ids))
            existing.SetElementFilter(final_filter)
            logger.debug("Updated existing filter: {0}".format(filter_name))
            return existing
        else:
            new_pfe = DB.ParameterFilterElement.Create(doc, filter_name, List[DB.ElementId](cat_ids))
            new_pfe.SetElementFilter(final_filter)
            logger.debug("Created new filter: {0}".format(filter_name))
            return new_pfe
    except Exception as ex:
        logger.debug("Failed to create or update filter '{0}': {1}".format(filter_name, ex))
        return None



# -----------------------------------------------------------------------------
# 7) Main
# -----------------------------------------------------------------------------
def main():
    active_view = revit.active_view
    if not isinstance(active_view, DB.ViewPlan) or active_view.ViewType != DB.ViewType.FloorPlan:
        forms.alert("Active view must be a floor plan to create a view template.",exitscript=True)

    all_panels = get_all_panel_names(doc)
    if not all_panels:
        forms.alert("No panel names found on Electrical Equipment with a Distribution System. Nothing to do.")
        return

    selection = forms.SelectFromList.show(
        all_panels, multiselect=True,
        title="Color Circuits by Panel: choose included panels",
        width=500, height=400, button_name="Use Selected"
    )
    if not selection:
        return

    include_set = set(selection)
    solid_id = get_solid_fill_pattern_id(doc)

    # MODIFIED: Generate maximally contrasting colors based on selection count
    selected_count = len(selection)
    logger.debug("Generating {0} maximally contrasting colors for selected panels".format(selected_count))

    try:
        contrast_colors = generate_max_contrast_colors(selected_count)
        logger.debug("Successfully generated {0} contrasting colors".format(len(contrast_colors)))
    except Exception as ex:
        logger.debug("Failed to generate contrasting colors: {0}. Using fallback palette.".format(ex))
        contrast_colors = COLOR_PALETTE[:selected_count]

    # Create mapping of panel names to colors
    selected_panels = sorted(list(include_set))
    panel_color_map = {}
    for i, panel in enumerate(selected_panels):
        if i < len(contrast_colors):
            panel_color_map[panel] = contrast_colors[i]
        else:
            # Fallback if we somehow don't have enough colors
            panel_color_map[panel] = COLOR_PALETTE[i % len(COLOR_PALETTE)]

    template = None
    legend_view = None
    color_map = {}
    filter_override_data = []

    with DB.TransactionGroup(doc, "Color Circuits by Panel") as tg:
        tg.Start()

        with DB.Transaction(doc, "Create/Update Filters") as tx1:
            tx1.Start()
            for pn in all_panels:
                # Use the generated contrasting color if panel is selected, otherwise grey
                if pn in include_set:
                    rgb = panel_color_map[pn]
                else:
                    rgb = GREY

                color_map[pn] = rgb
                pfe = create_or_update_panel_filter_logical_or(pn)
                if pfe:
                    use_halftone = pn not in include_set
                    ogs = build_overrides(rgb, use_halftone, solid_id)
                    filter_override_data.append((pfe, ogs))
            tx1.Commit()

        with DB.Transaction(doc, "View Template Setup") as tx2:
            tx2.Start()
            template = get_or_create_view_template(VIEW_TEMPLATE_NAME)
            if template:
                enforce_template_controls_only_filters(template)
                apply_filters_to_template(template, filter_override_data)
            tx2.Commit()

        with DB.Transaction(doc, "Legend Creation") as tx21:
            tx21.Start()
            legend_view = get_or_create_drafting_view(LEGEND_VIEW_NAME, 48, template)
            tx21.Commit()

        with DB.Transaction(doc, "Legend Creation") as tx3:
            tx3.Start()
            # Before calling legend view function
            fr_type = get_filled_region_type("PanelChecker - Solid Fill")

            if not fr_type:
                logger.debug("No filled region type could be created.")
                return
            create_or_update_legend_drafting_view(legend_view, list(color_map.items()), template, fr_type)

            tx3.Commit()

        with DB.Transaction(doc, "Activate View Template") as tx4:
            tx4.Start()
            if template:
                activate_temp_view_mode(revit.active_view, template)
            tx4.Commit()

        tg.Assimilate()

    forms.alert("Filters applied to view template '{0}'. View switched to Temporary Template Mode.".format(VIEW_TEMPLATE_NAME))

if __name__ == "__main__":
    try:
        main()
    except Exception as ex:
        logger.exception("Color Circuits by Panel failed: {0}".format(ex))